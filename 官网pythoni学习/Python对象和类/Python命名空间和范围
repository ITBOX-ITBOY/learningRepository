在本文中，您将了解命名空间; 从名称到对象的映射以及变量的范围。

一、Python命名空间和范围
    名称（也称为标识符）只是一个给对象的名称。Python中的一切都是一个对象。名称是访问底层对象的一种方法。
      例如，当我们进行赋值a = 2时，这里2是一个存储在内存中的对象，a是我们将其关联的名称。
      我们可以得到通过某个对象的地址（RAM）的内置功能，id()。我们来看看吧
        # Note: You may get different value of id
        a = 2
        # Output: id(2)= 10919424
        print('id(2) =', id(2))
        # Output: id(a) = 10919424
        print('id(a) =', id(a))
        这里，两者都是指相同的对象。让我们再来一些有趣的事情。
        # Note: You may get different value of id
        a = 2
        # Output: id(a) = 10919424
        print('id(a) =', id(a))
        a = a+1
        # Output: id(a) = 10919456
        print('id(a) =', id(a))
        # Output: id(3) = 10919456
        print('id(3) =', id(3))
        b = 2
        # Output: id(2)= 10919424
        print('id(2) =', id(2))


        最初，一个对象2被创建并命名一个与它关联，当我们这样做a = a+1，一个新的对象3被创建，现在一个与此对象关联。
        请注意id(a)并id(3)具有相同的值。
        此外，当我们这样做b = 2时，新的名字b与上一个对象相关联2。
        这是有效的，因为Python不必创建一个新的重复对象。名称绑定的这种动态性使Python成为强大的; 一个名字可以指任何类型的对象。

        >>> a = 5
        >>> a = 'Hello World!'
        >>> a = [1,2,3]

        所有这些都是有效的，一会是指三种不同类型的对象，在不同的情况下。函数也是对象，所以名字也可以引用它们。
            def printHello():
                print("Hello")
            a = printHello()

            # Output: Hello
            a
        我们的同名一个可以参照的功能，我们可以通过它调用的函数，整齐漂亮。

二、什么是命名空间？
        1、简单来说，命名空间是一个名称的集合。
        2、在Python中，您可以将命名空间设想为已定义的每个名称对应的对象。
        3、不同的命名空间可以在给定的时间共存，但完全隔离。

        当我们启动Python解释器时，创建包含所有内置名称的命名空间，只要我们不退出就会存在。
        这是一个像内置功能的原因id()，print()等总是提供给我们从程序的任何部分。每个模块创建自己的全局命名空间。
        这些不同的命名空间是孤立的。因此，不同模块中可能存在的相同名称不会相互冲突。
        模块可以有各种功能和类。调用一个函数时创建一个本地命名空间，其中定义了所有名称。类似的，就是类的情况。下图可能有助于澄清这个概念。

三、Python变量范围
        虽然定义了各种独特的命名空间，但是我们可能无法从程序的每个部分访问它们。范围的概念发挥作用。
        范围是可以直接访问命名空间的任何前缀的程序部分。
        在任何给定的时刻，至少有三个嵌套范围。
        具有本地名称的当前功能的范围
        具有全局名称的模块范围
        具有内置名称的最外层
        当在函数中引用引用时，将在本地命名空间中搜索该名称，然后在全局命名空间中搜索该名称，最后在内置命名空间中进行搜索。
        如果另一个函数内有函数，则新的范围将嵌套在本地作用域内。

    Python范围和命名空间示例
        def outer_function():
            b = 20
            def inner_func():
                c = 30

        a = 10

    变量a在全局命名空间中。
    变量b位于本地命名空间中outer_function()，
    变量c位于嵌套的本地命名空间中inner_function()。
    当我们在inner_function()，c是我们本地的，b是非本地的，而a是全局的。
    我们可以阅读，以及分配新值ç但只能读取b和c ^从inner_function()。
    如果我们尝试分配作为值b，一个新的变量b在本地命名空间比非本地不同的创建b。当我们为a分配一个值时，会发生同样的事情。
    但是，如果我们宣布一个为全球性的，所有参考，并分配到全球的一个。
    同样，如果我们要重新绑定变量b，它必须被声明为非本地的。以下示例将进一步澄清。
        def outer_function():
            a = 20
            def inner_function():
                a = 30
                print('a =',a)

            inner_function()
            print('a =',a)

        a = 10
        outer_function()
        print('a =',a)
        你可以看到，这个程序的输出是

        a = 30
        a = 20
        a = 10
        在这个程序中，三个不同的变量一个在单独的名称空间中定义，并相应地进行访问。在以下程序中

        def outer_function():
            global a
            a = 20
            def inner_function():
                global a
                a = 30
                print('a =',a)

            inner_function()
            print('a =',a)

        a = 10
        outer_function()
        print('a =',a)

        程序的输出是。

        a = 30
        a = 30
        a = 30
        在这里，所有的参考和分配是全球一个由于使用关键字global。